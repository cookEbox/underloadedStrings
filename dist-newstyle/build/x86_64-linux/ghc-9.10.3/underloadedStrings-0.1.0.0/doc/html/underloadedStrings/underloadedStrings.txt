-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Useful functions if you are not using the OverloadedStrings Pragma
@package underloadedStrings
@version 0.1.0.0


-- | This tiny utility module gives you lightweight, explicit helpers for
--   moving between <a>String</a>, strict <a>Text</a>, lazy <a>Text</a>
--   (<a>LazyText</a>), strict <a>ByteString</a>, and lazy
--   <a>ByteString</a>—without enabling <tt>OverloadedStrings</tt>.
--   
--   It also includes “apply-with-conversion” operators so you can pass a
--   <a>String</a> literal directly to a function that expects one of these
--   other types:
--   
--   <pre>
--   import qualified Data.Text as Text
--   import qualified Data.ByteString as BS
--   import qualified Data.ByteString.Lazy as LBS
--   
--   Text.length  #  "hello"   -- 5
--   Text.length ~# "hello"    -- 5 (lazy Text)
--   BS.length    &amp;  "hello"   -- 5
--   LBS.length   ~&amp; "hello"   -- 5
--   </pre>
--   
--   ### Notes
--   
--   <ul>
--   <li>Functions using <tt><a>Data.ByteString.Char8</a></tt>
--   (<tt>B8</tt>) are **byte-wise**: they treat characters as their low 8
--   bits. That’s convenient but **lossy** for non-ASCII. Prefer UTF-8
--   conversions when correctness matters.</li>
--   <li>UTF-8 decoders here use <a>decodeUtf8</a>, which will **throw** a
--   <tt>UnicodeException</tt> on invalid input. If you need a total
--   function, prefer the primed variants from
--   <tt><a>Data.Text.Encoding</a></tt> (e.g. <a>decodeUtf8</a> →
--   <tt>decodeUtf8'</tt>).</li>
--   </ul>
module Underloaded.Strings

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | Lazy <a>Text</a> alias, re-exported as <a>LazyText</a>.
type LazyText = Text

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | Type synonym for the lazy flavour of <a>ByteString</a>.
type LazyByteString = ByteString

-- | Pack a <a>String</a> into strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; T.length (t "hello")
--   5
--   </pre>
t :: String -> Text

-- | Pack a <a>String</a> into lazy <a>LazyText</a>.
--   
--   <pre>
--   &gt;&gt;&gt; TL.length (lt "hello")
--   5
--   </pre>
lt :: String -> LazyText

-- | Pack a <a>String</a> into a strict <a>ByteString</a> using
--   <tt><a>Data.ByteString.Char8</a></tt>. Each Char is truncated to 8
--   bits (byte-wise). **Lossy for non-ASCII.**
--   
--   <pre>
--   &gt;&gt;&gt; B8.length (b "abc")
--   3
--   </pre>
b :: String -> ByteString

-- | Pack a <a>String</a> into a lazy <a>ByteString</a> (Char8 semantics).
--   **Lossy for non-ASCII.**
--   
--   <pre>
--   &gt;&gt;&gt; LBS.length (lb "abc")
--   3
--   </pre>
lb :: String -> LazyByteString

-- | Apply a function expecting strict <a>Text</a> to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; T.length # "hello"
--   5
--   </pre>
(#) :: (Text -> b) -> String -> b
infixr 0 #

-- | Apply a function expecting lazy <a>LazyText</a> to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; TL.length ~# "hello"
--   5
--   </pre>
(~#) :: (Text -> b) -> String -> b
infixr 0 ~#

-- | Apply a function expecting strict <a>ByteString</a> (Char8) to a
--   <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; B8.length &amp; "hello"
--   5
--   </pre>
(&) :: (ByteString -> b) -> String -> b
infixr 0 &

-- | Apply a function expecting lazy <a>ByteString</a> (Char8) to a
--   <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; LBS.length ~&amp; "hello"
--   5
--   </pre>
(~&) :: (LazyByteString -> b) -> String -> b
infixr 0 ~&

-- | Strict <a>ByteString</a> (assumed UTF-8) → strict <a>Text</a>. Throws
--   <tt>UnicodeException</tt> on invalid UTF-8.
--   
--   <pre>
--   &gt;&gt;&gt; b2t (encodeUtf8 (t "hi"))
--   "hi"
--   </pre>
b2t :: ByteString -> Text

-- | Strict <a>Text</a> → strict <a>ByteString</a> (UTF-8).
--   
--   <pre>
--   &gt;&gt;&gt; t2b (t "hi") == encodeUtf8 (t "hi")
--   True
--   </pre>
t2b :: Text -> ByteString

-- | Strict <a>Text</a> → lazy <a>ByteString</a> (UTF-8).
--   
--   <pre>
--   &gt;&gt;&gt; LBS.toStrict (t2lb (t "x")) == encodeUtf8 (t "x")
--   True
--   </pre>
t2lb :: Text -> LazyByteString

-- | Lazy <a>ByteString</a> (assumed UTF-8) → strict <a>Text</a>. Throws
--   <tt>UnicodeException</tt> on invalid UTF-8.
--   
--   <pre>
--   &gt;&gt;&gt; lb2t (t2lb (t "yo"))
--   "yo"
--   </pre>
lb2t :: LazyByteString -> Text

-- | Lazy <a>ByteString</a> (Char8 semantics) → <a>String</a> (byte-wise /
--   lossy).
--   
--   <pre>
--   &gt;&gt;&gt; lb2s (lb "abc")
--   "abc"
--   </pre>
lb2s :: LazyByteString -> String

-- | Lazy → strict <a>ByteString</a> (no re-encoding).
--   
--   <pre>
--   &gt;&gt;&gt; lb2b (lb "a") == b "a"
--   True
--   </pre>
lb2b :: LazyByteString -> ByteString

-- | Strict → lazy <a>ByteString</a> (no re-encoding).
--   
--   <pre>
--   &gt;&gt;&gt; LBS.toStrict (b2lb (b "a")) == b "a"
--   True
--   </pre>
b2lb :: ByteString -> LazyByteString

-- | Strict <a>Text</a> → <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; t2s (t "ok")
--   "ok"
--   </pre>
t2s :: Text -> String

-- | Strict <a>ByteString</a> (Char8 semantics) → <a>String</a> (byte-wise
--   / lossy).
--   
--   <pre>
--   &gt;&gt;&gt; b2s (b "abc")
--   "abc"
--   </pre>
b2s :: ByteString -> String

-- | Concatenate a list of <a>String</a>s and build a strict
--   <a>ByteString</a> (Char8). Handy for tiny messages. **Lossy for
--   non-ASCII.**
--   
--   <pre>
--   &gt;&gt;&gt; bc ["he","llo"] == b "hello"
--   True
--   </pre>
bc :: [String] -> ByteString

-- | Concatenate a list of <a>String</a>s and build a lazy
--   <a>ByteString</a> (Char8). **Lossy for non-ASCII.**
--   
--   <pre>
--   &gt;&gt;&gt; lbc ["he","llo"] == lb "hello"
--   True
--   </pre>
lbc :: [String] -> LazyByteString

-- | Concatenate a list of <a>String</a>s and build strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tc ["a","b","c"]
--   "abc"
--   </pre>
tc :: [String] -> Text

-- | Concatenate a list of <a>String</a>s and build lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; TL.toStrict (ltc ["a","b","c"])
--   "abc"
--   </pre>
ltc :: [String] -> Text
